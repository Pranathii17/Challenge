<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ArtPoster </title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0e0f13;
    --panel: #191b22;
    --muted: #9aa0aa;
    --accent: #6ea8fe;
    --btn: #242733;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; background: var(--bg); color: #e9eef5;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display: grid; grid-template-columns: 300px 1fr; height: 100vh;
  }
  header {
    grid-column: 1 / -1; padding: 10px 16px; background: #0a0b0e; border-bottom: 1px solid #161820;
    display: flex; align-items: center; gap: 10px;
  }
  header .title { font-weight: 800; letter-spacing: .3px; }
  header .sub { color: var(--muted); font-size: 12px; margin-left: 6px; }
  #sidebar {
    padding: 14px; background: var(--panel); border-right: 1px solid #161820;
    display: flex; flex-direction: column; gap: 14px; overflow: auto;
  }
  .group { background: #1b1e28; border: 1px solid #1f2330; border-radius: 12px; padding: 12px; }
  .group h3 { margin: 0 0 10px; font-size: 13px; color: #c8ced7; text-transform: uppercase; letter-spacing: .8px; }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
  button, label.btn {
    background: var(--btn); color: #e9eef5; border: 1px solid #2b3040; border-radius: 10px;
    padding: 8px 10px; font-size: 13px; cursor: pointer; text-align: center;
  }
  button:hover, label.btn:hover { filter: brightness(1.08); }
  input[type="color"], input[type="range"], input[type="number"], input[type="text"], select {
    width: 100%; background: #141722; border: 1px solid #2b3040; color: #e9eef5;
    border-radius: 10px; padding: 6px 8px; font-size: 13px;
  }
  #stageWrap {
    display: grid; place-items: center; background: radial-gradient(1000px 400px at 50% 0%, #10131b, #0a0b0f);
    position: relative; overflow: hidden;
  }
  #canvas {
    background: #0b0f16; border: 1px solid #22283a; border-radius: 16px;
  }
  .hint { color: var(--muted); font-size: 12px; line-height: 1.3; margin-top: 6px; }
  .badge { background: #121520; border: 1px solid #2b3040; color: #b8bfd0; padding: 2px 8px; border-radius: 999px; font-size: 11px; }
  footer {
    position: absolute; left: 12px; bottom: 12px; color: #9aa0aa; font-size: 12px;
  }
</style>
</head>
<body>
  <header>
    <span class="title">ArtPoster Studio</span>
    <span class="sub">— HTML + Internal CSS, no libraries</span>
    <span class="badge">Drag • Resize • Rotate • Export</span>
  </header>

  <aside id="sidebar">
    <div class="group">
      <h3>Canvas</h3>
      <div class="row">
        <div>
          <label style="font-size:12px;color:#c8ced7">Width</label>
          <input id="w" type="number" min="300" max="2000" value="800">
        </div>
        <div>
          <label style="font-size:12px;color:#c8ced7">Height</label>
          <input id="h" type="number" min="300" max="3000" value="1200">
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="applySize">Apply Size</button>
        <button id="export">Export PNG</button>
      </div>
      <div class="hint">Tip: Use mouse to move. Drag corners to resize, top circle to rotate.</div>
    </div>

    <div class="group">
      <h3>Background</h3>
      <div class="row">
        <select id="bgMode">
          <option value="solid">Solid</option>
          <option value="gradient" selected>Gradient</option>
        </select>
        <button id="randGrad">Random</button>
      </div>
      <div class="row" style="margin-top:8px">
        <input id="bg1" type="color" value="#1d4ed8">
        <input id="bg2" type="color" value="#9333ea">
      </div>
      <div style="margin-top:8px">
        <label style="font-size:12px;color:#c8ced7">Angle</label>
        <input id="bgAngle" type="range" min="0" max="360" value="135">
      </div>
    </div>

    <div class="group">
      <h3>Add Elements</h3>
      <div class="row">
        <button id="addText">Text</button>
        <button id="addRect">Rectangle</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="addCircle">Circle</button>
        <label class="btn" for="imgUpload">Image</label>
        <input id="imgUpload" type="file" accept="image/*" style="display:none">
      </div>
    </div>

    <div class="group">
      <h3>Inspector</h3>
      <div class="hint" id="noSel">Nothing selected.</div>
      <div id="inspector" style="display:none">
        <div style="margin-bottom:8px"><span class="badge" id="selType">type</span></div>
        <div class="row">
          <div>
            <label style="font-size:12px;color:#c8ced7">X</label>
            <input id="ix" type="number" step="1">
          </div>
          <div>
            <label style="font-size:12px;color:#c8ced7">Y</label>
            <input id="iy" type="number" step="1">
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label style="font-size:12px;color:#c8ced7">W</label>
            <input id="iw" type="number" step="1">
          </div>
          <div>
            <label style="font-size:12px;color:#c8ced7">H</label>
            <input id="ih" type="number" step="1">
          </div>
        </div>
        <div class="row" style="margin-top:8px">
          <div>
            <label style="font-size:12px;color:#c8ced7">Rotate</label>
            <input id="irot" type="number" step="1">
          </div>
          <div>
            <label style="font-size:12px;color:#c8ced7">Opacity</label>
            <input id="iop" type="range" min="0.05" max="1" step="0.01">
          </div>
        </div>
        <div id="textControls" style="margin-top:8px;display:none">
          <label style="font-size:12px;color:#c8ced7">Text</label>
          <input id="itext" type="text">
          <div class="row" style="margin-top:8px">
            <input id="ifont" type="text" placeholder="Font (e.g., 48px Poppins)">
            <input id="icolor" type="color" value="#ffffff">
          </div>
        </div>
        <div id="shapeControls" style="margin-top:8px;display:none">
          <label style="font-size:12px;color:#c8ced7">Fill</label>
          <input id="ifill" type="color" value="#22d3ee">
        </div>
        <div class="row" style="margin-top:10px">
          <button id="front">Bring Front</button>
          <button id="back">Send Back</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="dup">Duplicate</button>
          <button id="del">Delete</button>
        </div>
      </div>
    </div>

    <div class="group">
      <h3>Project</h3>
      <div class="row">
        <button id="clear">Clear</button>
        <button id="demo">Demo</button>
      </div>
    </div>
  </aside>

  <main id="stageWrap">
    <canvas id="canvas" width="800" height="1200"></canvas>
    <footer>© <span id="yr"></span> ArtPoster Studio</footer>
  </main>

<script>
(() => {
  // ----- State -----
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let bg = { mode: 'gradient', c1: '#1d4ed8', c2: '#9333ea', angle: 135 };
  let elements = []; // each: {id,type,x,y,w,h,rot,op, fill?, text?, font?, color?, img?}
  let activeId = null;

  // interaction
  let hoverHandle = null; // 'move' | 'nw'|'ne'|'sw'|'se' | 'rot'
  let drag = null; // {id, kind, startX,Y, ...}

  // ----- Utilities -----
  const uid = () => Math.random().toString(36).slice(2,9);
  const rad = d => d * Math.PI / 180;
  const clamp = (n,a,b) => Math.max(a, Math.min(b, n));

  function drawBackground() {
    if (bg.mode === 'solid') {
      ctx.fillStyle = bg.c1; ctx.fillRect(0,0,canvas.width, canvas.height);
    } else {
      const ang = rad(bg.angle);
      const cx = canvas.width/2, cy = canvas.height/2;
      const len = Math.hypot(canvas.width, canvas.height);
      const x0 = cx - Math.cos(ang)*len, y0 = cy - Math.sin(ang)*len;
      const x1 = cx + Math.cos(ang)*len, y1 = cy + Math.sin(ang)*len;
      const g = ctx.createLinearGradient(x0,y0,x1,y1);
      g.addColorStop(0, bg.c1); g.addColorStop(1, bg.c2);
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width, canvas.height);
    }
  }

  function drawElement(el, isActive) {
    ctx.save();
    ctx.translate(el.x + el.w/2, el.y + el.h/2);
    ctx.rotate(rad(el.rot||0));
    ctx.globalAlpha = el.op ?? 1;

    if (el.type === 'rect') {
      ctx.fillStyle = el.fill || '#22d3ee';
      roundRect(-el.w/2, -el.h/2, el.w, el.h, 16);
      ctx.fill();
    } else if (el.type === 'circle') {
      ctx.fillStyle = el.fill || '#a78bfa';
      const r = Math.min(el.w, el.h)/2;
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
    } else if (el.type === 'text') {
      ctx.fillStyle = el.color || '#fff';
      ctx.font = el.font || 'bold 48px Arial';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      wrapText(el.text || 'Text', 0, 0, el.w, el.h);
    } else if (el.type === 'image' && el.img) {
      // cover
      const iw = el.img.width, ih = el.img.height;
      const r = Math.max(el.w/iw, el.h/ih);
      const dw = iw*r, dh = ih*r;
      ctx.save();
      roundRect(-el.w/2, -el.h/2, el.w, el.h, 20); ctx.clip();
      ctx.drawImage(el.img, -dw/2, -dh/2, dw, dh);
      ctx.restore();
    }

    if (isActive) drawBounding(el);

    ctx.restore();
  }

  function wrapText(text, x, y, w, h) {
    const words = String(text).split(/\s+/);
    let line = '', lines = [], maxLines = Math.max(1, Math.floor(h / getLineHeight()));
    for (let i=0;i<words.length;i++){
      const test = line ? line + ' ' + words[i] : words[i];
      if (ctx.measureText(test).width > w && line) {
        lines.push(line); line = words[i];
      } else line = test;
      if (lines.length >= maxLines) break;
    }
    if (lines.length < maxLines && line) lines.push(line);
    const total = lines.length * getLineHeight();
    let off = -total/2 + getLineHeight()/2;
    for (const L of lines) { ctx.fillText(L, x, y + off); off += getLineHeight(); }
  }
  function getLineHeight(){ return parseInt(ctx.font,10) * 1.2; }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }

  function drawBounding(el) {
    ctx.save();
    ctx.strokeStyle = '#ffffffaa'; ctx.lineWidth = 1.5;
    roundRect(-el.w/2, -el.h/2, el.w, el.h, 2); ctx.stroke();

    // corner handles
    const hs = 8;
    const corners = [
      [-el.w/2, -el.h/2, 'nw'], [el.w/2, -el.h/2, 'ne'],
      [-el.w/2, el.h/2, 'sw'],  [el.w/2, el.h/2, 'se']
    ];
    ctx.fillStyle = '#0a0';
    for (const [cx, cy] of corners) { ctx.fillRect(cx-hs/2, cy-hs/2, hs, hs); }

    // rotation handle (top middle)
    const ry = -el.h/2 - 24;
    ctx.beginPath(); ctx.moveTo(0, -el.h/2); ctx.lineTo(0, ry); ctx.stroke();
    ctx.beginPath(); ctx.arc(0, ry, 6, 0, Math.PI*2); ctx.fillStyle = '#08f'; ctx.fill();
    ctx.restore();
  }

  function render() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawBackground();
    for (const el of elements) drawElement(el, el.id === activeId);
  }

  // ----- Hit testing -----
  function screenToLocal(el, sx, sy) {
    // convert screen point to el's local coordinates (with rotation)
    const cx = el.x + el.w/2, cy = el.y + el.h/2;
    const dx = sx - cx, dy = sy - cy;
    const a = rad(-(el.rot||0));
    const lx = dx * Math.cos(a) - dy * Math.sin(a);
    const ly = dx * Math.sin(a) + dy * Math.cos(a);
    return { lx, ly };
  }

  function hitTestHandle(el, sx, sy) {
    const { lx, ly } = screenToLocal(el, sx, sy);
    const hs = 8;
    const corners = {
      nw: { x: -el.w/2, y: -el.h/2 },
      ne: { x:  el.w/2, y: -el.h/2 },
      sw: { x: -el.w/2, y:  el.h/2 },
      se: { x:  el.w/2, y:  el.h/2 },
    };
    for (const k in corners) {
      const c = corners[k];
      if (Math.abs(lx - c.x) <= hs && Math.abs(ly - c.y) <= hs) return k;
    }
    // rotation handle
    const ry = -el.h/2 - 24;
    const dist = Math.hypot(lx - 0, ly - ry);
    if (dist <= 8) return 'rot';

    // inside rect?
    if (lx >= -el.w/2 && lx <= el.w/2 && ly >= -el.h/2 && ly <= el.h/2) return 'move';
    return null;
  }

  function pickTop(sx, sy) {
    for (let i = elements.length - 1; i >= 0; i--) {
      const el = elements[i];
      if (hitTestHandle(el, sx, sy)) return el;
    }
    return null;
  }

  // ----- Mouse events -----
  canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    const el = pickTop(x, y);
    if (!el) { activeId = null; render(); updateInspector(); return; }
    activeId = el.id;
    const handle = hitTestHandle(el, x, y);
    drag = { id: el.id, kind: handle, startX: x, startY: y, start: { ...el } };
    if (handle === 'move') bringToFront(el.id);
    render(); updateInspector();
  });

  canvas.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left, y = e.clientY - r.top;
    const el = elements.find(x => x.id === activeId);
    if (!drag) {
      // hover cursor
      const top = pickTop(x,y);
      canvas.style.cursor = top ? (hitTestHandle(top, x, y) === 'move' ? 'move' :
        hitTestHandle(top, x, y) === 'rot' ? 'alias' : 'nwse-resize') : 'default';
      return;
    }
    const d = elements.find(x => x.id === drag.id); if (!d) return;
    const dx = x - drag.startX, dy = y - drag.startY;

    if (drag.kind === 'move') {
      d.x = drag.start.x + dx;
      d.y = drag.start.y + dy;
    } else if (['nw','ne','sw','se'].includes(drag.kind)) {
      const s = resizeFromCorner(drag.kind, drag.start, dx, dy);
      Object.assign(d, s);
    } else if (drag.kind === 'rot') {
      const cx = drag.start.x + drag.start.w/2, cy = drag.start.y + drag.start.h/2;
      const ang = Math.atan2(y - cy, x - cx) * 180/Math.PI + 90; // top handle
      d.rot = Math.round(ang);
    }
    render(); updateInspectorFieldsOnly();
  });

  window.addEventListener('mouseup', () => { drag = null; });

  function resizeFromCorner(corner, start, dx, dy) {
    // simple proportional-free resizing
    let { x, y, w, h } = start;
    // ignore rotation for simplicity while resizing; apply axis-aligned deltas
    if (corner === 'se') { w = Math.max(20, w + dx); h = Math.max(20, h + dy); }
    if (corner === 'sw') { w = Math.max(20, w - dx); h = Math.max(20, h + dy); x = x + dx; }
    if (corner === 'ne') { w = Math.max(20, w + dx); h = Math.max(20, h - dy); y = y + dy; }
    if (corner === 'nw') { w = Math.max(20, w - dx); h = Math.max(20, h - dy); x = x + dx; y = y + dy; }
    return { x, y, w, h };
  }

  // ----- Elements ops -----
  function addElement(el) { elements.push(el); activeId = el.id; render(); updateInspector(); }
  function bringToFront(id) {
    const idx = elements.findIndex(e => e.id === id);
    if (idx >= 0) { const [it] = elements.splice(idx,1); elements.push(it); }
  }
  function sendToBack(id) {
    const idx = elements.findIndex(e => e.id === id);
    if (idx >= 0) { const [it] = elements.splice(idx,1); elements.unshift(it); }
  }
  function duplicate(id) {
    const src = elements.find(e => e.id === id); if (!src) return;
    const copy = JSON.parse(JSON.stringify(src));
    copy.id = uid(); copy.x += 20; copy.y += 20;
    // image object cannot be cloned via JSON; keep reference
    if (src.type === 'image') copy.img = src.img;
    elements.push(copy); activeId = copy.id; render(); updateInspector();
  }
  function remove(id) {
    const i = elements.findIndex(e => e.id === id);
    if (i >= 0) elements.splice(i,1); activeId = null; render(); updateInspector();
  }

  // ----- Sidebar controls -----
  const qs = id => document.getElementById(id);
  const wIn = qs('w'), hIn = qs('h'), applySize = qs('applySize'),
        exportBtn = qs('export'), clearBtn = qs('clear'), demoBtn = qs('demo');

  const bgMode = qs('bgMode'), bg1 = qs('bg1'), bg2 = qs('bg2'),
        bgAngle = qs('bgAngle'), randGrad = qs('randGrad');

  const addTextBtn = qs('addText'), addRectBtn = qs('addRect'),
        addCircleBtn = qs('addCircle'), imgUpload = qs('imgUpload');

  const inspector = qs('inspector'), noSel = qs('noSel'), selType = qs('selType');
  const ix = qs('ix'), iy = qs('iy'), iw = qs('iw'), ih = qs('ih'),
        irot = qs('irot'), iop = qs('iop'),
        textControls = qs('textControls'), itext = qs('itext'),
        ifont = qs('ifont'), icolor = qs('icolor'),
        shapeControls = qs('shapeControls'), ifill = qs('ifill'),
        frontBtn = qs('front'), backBtn = qs('back'), dupBtn = qs('dup'), delBtn = qs('del');

  applySize.onclick = () => {
    const W = clamp(parseInt(wIn.value||800), 300, 2000);
    const H = clamp(parseInt(hIn.value||1200), 300, 3000);
    canvas.width = W; canvas.height = H; render();
  };
  exportBtn.onclick = () => {
    const link = document.createElement('a');
    link.download = `artposter-${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  };
  clearBtn.onclick = () => { elements = []; activeId = null; render(); updateInspector(); };
  demoBtn.onclick = () => {
    elements = [];
    addElement({ id: uid(), type:'rect', x:60,y:120,w:420,h:110, rot:0, op:0.25, fill:'#000000' });
    addElement({ id: uid(), type:'circle', x:520,y:320,w:300,h:300, rot:0, op:1, fill:'#a78bfa' });
    addElement({ id: uid(), type:'text', x:80,y:180,w:640,h:180, rot:-6, op:1, text:'ARTPOSTER\nSTUDIO', font:'900 98px Arial', color:'#ffffff' });
    addElement({ id: uid(), type:'text', x:84,y:380,w:620,h:100, rot:0, op:.9, text:'Make stunning posters in your browser', font:'600 28px Arial', color:'#d7def0' });
  };

  bgMode.oninput = () => { bg.mode = bgMode.value; render(); };
  [bg1, bg2].forEach(inp => inp.oninput = () => { bg.c1 = bg1.value; bg.c2 = bg2.value; render(); });
  bgAngle.oninput = () => { bg.angle = +bgAngle.value; render(); };
  randGrad.onclick = () => {
    bg.mode = 'gradient';
    const rnd = () => '#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');
    bg.c1 = rnd(); bg.c2 = rnd(); bg1.value = bg.c1; bg2.value = bg.c2;
    bg.angle = Math.floor(Math.random()*360); bgAngle.value = bg.angle; render();
  };

  addTextBtn.onclick = () => {
    const txt = prompt('Enter text', 'Your Headline'); if (txt === null) return;
    addElement({ id: uid(), type:'text', x:80,y:120,w:500,h:160, rot:0, op:1, text:txt, font:'800 64px Arial', color:'#ffffff' });
  };
  addRectBtn.onclick = () => addElement({ id: uid(), type:'rect', x:60,y:60,w:260,h:140, rot:0, op:1, fill:'#22d3ee' });
  addCircleBtn.onclick = () => addElement({ id: uid(), type:'circle', x:340,y:420,w:220,h:220, rot:0, op:1, fill:'#ef4444' });

  imgUpload.onchange = e => {
    const f = e.target.files?.[0]; if (!f) return;
    const img = new Image();
    const url = URL.createObjectURL(f);
    img.onload = () => {
      addElement({ id: uid(), type:'image', x: canvas.width/2-180, y: canvas.height/2-240, w:360, h:480, rot:0, op:1, img });
      URL.revokeObjectURL(url);
    };
    img.src = url;
  };

  // inspector bindings
  function updateInspector() {
    const el = elements.find(e => e.id === activeId);
    if (!el) { inspector.style.display = 'none'; noSel.style.display = 'block'; return; }
    inspector.style.display = 'block'; noSel.style.display = 'none';
    selType.textContent = el.type.toUpperCase();
    ix.value = Math.round(el.x); iy.value = Math.round(el.y);
    iw.value = Math.round(el.w); ih.value = Math.round(el.h);
    irot.value = Math.round(el.rot||0); iop.value = el.op ?? 1;

    textControls.style.display = el.type === 'text' ? 'block' : 'none';
    if (el.type === 'text') {
      itext.value = el.text || '';
      ifont.value = el.font || 'bold 48px Arial';
      icolor.value = hexFromColor(el.color || '#ffffff');
    }
    shapeControls.style.display = (el.type === 'rect' || el.type === 'circle') ? 'block' : 'none';
    if (el.type === 'rect' || el.type === 'circle') ifill.value = hexFromColor(el.fill || '#22d3ee');
  }

  function updateInspectorFieldsOnly(){ // lightweight
    const el = elements.find(e => e.id === activeId); if (!el) return;
    ix.value = Math.round(el.x); iy.value = Math.round(el.y);
    iw.value = Math.round(el.w); ih.value = Math.round(el.h);
    irot.value = Math.round(el.rot||0); iop.value = el.op ?? 1;
  }

  ix.oninput = () => { const e = sel(); if (e) { e.x = +ix.value; render(); } };
  iy.oninput = () => { const e = sel(); if (e) { e.y = +iy.value; render(); } };
  iw.oninput = () => { const e = sel(); if (e) { e.w = Math.max(20, +iw.value); render(); } };
  ih.oninput = () => { const e = sel(); if (e) { e.h = Math.max(20, +ih.value); render(); } };
  irot.oninput = () => { const e = sel(); if (e) { e.rot = +irot.value; render(); } };
  iop.oninput = () => { const e = sel(); if (e) { e.op = +iop.value; render(); } };

  itext.oninput = () => { const e = sel(); if (e && e.type==='text') { e.text = itext.value; render(); } };
  ifont.oninput = () => { const e = sel(); if (e && e.type==='text') { e.font = ifont.value; render(); } };
  icolor.oninput = () => { const e = sel(); if (e && e.type==='text') { e.color = icolor.value; render(); } };

  ifill.oninput = () => {
    const e = sel();
    if (e && (e.type==='rect' || e.type==='circle')) { e.fill = ifill.value; render(); }
  };

  frontBtn.onclick = () => { if (activeId) { bringToFront(activeId); render(); } };
  backBtn.onclick = () => { if (activeId) { sendToBack(activeId); render(); } };
  dupBtn.onclick = () => { if (activeId) duplicate(activeId); };
  delBtn.onclick = () => { if (activeId) remove(activeId); };

  function sel(){ return elements.find(e => e.id === activeId); }

  function hexFromColor(c) {
    // accepts '#rrggbb' or 'rgb(...)'; returns '#rrggbb'
    if (c.startsWith('#')) return c.slice(0,7);
    const m = c.match(/(\d+),\s*(\d+),\s*(\d+)/); if (!m) return '#ffffff';
    const [r,g,b] = m.slice(1,4).map(Number);
    return '#'+[r,g,b].map(n=>n.toString(16).padStart(2,'0')).join('');
  }

  // keyboard shortcuts
  window.addEventListener('keydown', e => {
    const eSel = sel(); if (!eSel) return;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
      e.preventDefault();
      const step = e.shiftKey ? 10 : 1;
      if (e.key==='ArrowUp') eSel.y -= step;
      if (e.key==='ArrowDown') eSel.y += step;
      if (e.key==='ArrowLeft') eSel.x -= step;
      if (e.key==='ArrowRight') eSel.x += step;
      render(); updateInspectorFieldsOnly();
    }
    if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='d') { e.preventDefault(); duplicate(eSel.id); }
    if (e.key==='Delete' || e.key==='Backspace') { e.preventDefault(); remove(eSel.id); }
  });

  // init
  document.getElementById('yr').textContent = new Date().getFullYear();
  render();
})();
</script>
</body>
</html>

